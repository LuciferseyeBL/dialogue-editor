<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>對話編輯神器：凜與GPT小天使的辛苦結晶 V5.6</title>

  <!-- 固定 UI 樣式（不讓使用者編輯） -->
  <style>
   @media (max-width: 768px) {
    #main {
      flex-direction: column;
    }

    #source {
      width: 100% !important;
      height: 30vh;
      border-right: none;
      border-bottom: 1px solid #ccc;
      font-size: 15px;
      line-height: 1.6;
    }

    #preview {
      width: 100% !important;
      height: 65vh;
      border-bottom: none;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch; /* 讓 iOS 裝置支援慣性滑動 */
      scroll-behavior: smooth;
      overscroll-behavior: contain;
    }
    .dialogue-content {
      font-size: 16px;
      line-height: 1.8;
    }

    .sender-name {
      font-size: 14px;
    }
    button {
      font-size: 14px;
    }
  }
    body { margin: 0; font-family: sans-serif; height: 100vh; display: flex; flex-direction: column; }
    #header { padding: 10px; border-bottom: 1px solid #ccc; text-align: center; font-weight: bold; }
    .role-name-inputs { display: flex; justify-content: space-between; padding: 5px 10px; }
    .role-name-inputs input { width: 48%; padding: 5px; }
    #main { display: flex; flex: 1; overflow: hidden; }
    #source {
      width: 30%; padding: 10px; border-right: 1px solid #ccc;
      box-sizing: border-box; overflow-y: auto;
    }
    #preview {
      width: 70%; padding: 10px; box-sizing: border-box;
      display: flex; flex-direction: column; overflow-y: auto;
      gap: 6px;
    }
    .dialogue {
      padding: 4px 28px 6px 8px;
      margin-top: 0;
      margin-bottom: 0;
      border-radius: 5px; position: relative;
      word-break: break-word; line-height: 1.6;
      display: flex; flex-direction: column;
    }
    .dialogue-content {
      white-space: pre-wrap;
    }
    .number {
      position: absolute; top: 0px; left: 6px;
      font-size: 11px; color: #888; line-height: 1;
    }
.switch-btn {
  position: absolute;
  top: -5px;
  right: 6px;
  font-size: 13px;
  background: none;
  border: none;
  cursor: pointer;
  color: #666;
  line-height: 1;
}

    .dialogue.dragging { opacity: 0.5; }
    #controls {
      padding: 10px; text-align: center; border-top: 1px solid #ccc;
      display: flex; justify-content: center; align-items: center;
      flex-wrap: wrap; gap: 10px;
    }
    .dialogue.chat-left, 
    .dialogue.chat-right {
      margin-top: 0;
      margin-bottom: 0;
    }
    .dialogue-content:empty::before {
      content: attr(placeholder);
      color: #999;
    }
    button { padding: 8px 15px; }
    #clearAllBtn { background: #f44336; color: white; }
    #styleEditorModal {
      position: fixed; top: 10%; left: 50%; transform: translateX(-50%);
      background: white; border: 1px solid #ccc; padding: 10px;
      z-index: 9999; width: 80%; height: 70%; display: none; flex-direction: column;
    }
    #styleEditorModal textarea {
      flex: 1; width: 100%; font-family: monospace;
      font-size: 14px; margin-bottom: 10px;
    }
  </style>

  <!-- 使用者可編輯的輸出樣式 -->
  <style id="output-style">
.chat-container {
  display: flex;
  flex-direction: column;
  gap: 20px; /* 對話框間距 */
  width: 100%;
  font-family: Arial, sans-serif;
  font-weight: 400; /* 對話框寬度 */
  max-width: 100%;
}
.chat-message {
  display: flex;
  flex-direction: column;
  width: 100%;
  max-width: 100%;
  margin-top: 0;
  margin-bottom: 0;
}
.sender-name {
  font-size: 12px; /* 修改人名相關設定 */
  font-weight: bold;
  margin-bottom: 3px;
  color: #666;
}
.chat-left, .chat-right {
  display: inline-block;
  padding: 10px;
  border-radius: 10px;
  word-wrap: break-word;
  white-space: pre-wrap;
  min-width: 40px;
  width: auto;
  margin-top: 0;
  margin-bottom: 0;
}
.chat-left {
  background-color: #f1f1f1; /* 左邊對話框背景色 */
  color: #3C3C3C; /* 左邊對話框字體色 */
  align-self: flex-start;
  max-width: 70%; /* 對話框寬度佔畫面百分比 */
}
.chat-right {
  background-color: #FFC1E0; /* 右邊對話框背景色 */
  color: #3C3C3C; /* 右邊對話框字體色 */
  align-self: flex-end;
  max-width: 70%;
}
  </style>
</head>
<body>
  <div style="text-align: right; padding: 10px;">
    <a href="https://github.com/LuciferseyeBL/dialogue-editor" target="_blank">
      📘 查看 GitHub 說明文件（README）
    </a>
  </div>
  <div id="header">📚 對話編輯神器：凜與GPT小天使的辛苦結晶 V5.6</div>
  <div class="role-name-inputs">
    <input id="leftRole" placeholder="左側角色名 (可留空)" />
    <input id="rightRole" placeholder="右側角色名 (可留空)" />
  </div>
  <div id="main">
    <div id="source" contenteditable="true"></div>
    <div id="preview"></div>
  </div>
  <div id="controls">
    <button onclick="openStyleEditor()">樣式設定</button>
    <button onclick="deleteSelected()">刪除</button>
    <button onclick="mergeNextSameSide()">合併下方同側</button>
    <button onclick="exportTxt()">匯出 TXT</button>
    <button onclick="toggleMode()">模式切換</button>
    <span id="mode-status">拖曳模式</span>
    <button id="clearAllBtn" onclick="clearAll()">全部清除</button>
    <button onclick="autoConvertFromSource()">🔄 自動轉換對話泡泡</button>
    <button onclick="flipAllSides()">↔ 一次性對調左右泡泡</button>
  </div>
  <div id="styleEditorModal">
    <textarea id="styleEditorArea"></textarea>
    <button onclick="applyStyle()">套用樣式</button>
    <button onclick="closeStyleEditor()">關閉</button>
  </div>
<script>
let selected = null;
let currentOrder = 1;
let mode = "drag";

const preview = document.getElementById("preview");
const modeStatus = document.getElementById("mode-status");
const leftInput = document.getElementById("leftRole");
const rightInput = document.getElementById("rightRole");
const source = document.getElementById("source");

function openStyleEditor() {
  const styleText = document.getElementById("output-style").textContent;
  document.getElementById("styleEditorArea").value = styleText;
  document.getElementById("styleEditorModal").style.display = "flex";
}

function closeStyleEditor() {
  document.getElementById("styleEditorModal").style.display = "none";
}

function applyStyle() {
  const updated = document.getElementById("styleEditorArea").value;
  document.getElementById("output-style").textContent = updated;
  syncPreviewStyle(); 
  closeStyleEditor();
}

function syncPreviewStyle() {
  const styleText = document.getElementById("output-style").textContent;
  const temp = document.createElement("style");
  temp.textContent = styleText;
  document.head.appendChild(temp);

  // ✅ 新增一個測試容器來讀取 .chat-container 的 gap
  const testContainer = document.createElement("div");
  testContainer.className = "chat-container";
  document.body.appendChild(testContainer);
  const computedContainer = getComputedStyle(testContainer);
  preview.style.gap = computedContainer.gap;
  document.body.removeChild(testContainer); // 清除測試容器

  const test = document.createElement("div");
  test.className = "chat-left";
  document.body.appendChild(test);
  const computed = getComputedStyle(test);

  const leftPreviewBoxes = document.querySelectorAll(".dialogue.chat-left");
  const rightPreviewBoxes = document.querySelectorAll(".dialogue.chat-right");

  leftPreviewBoxes.forEach(el => {
    el.style.backgroundColor = computed.backgroundColor;
    el.style.color = computed.color;
    el.style.padding = computed.padding;
    el.style.borderRadius = computed.borderRadius;
    el.style.maxWidth = computed.maxWidth;
    el.style.alignSelf = computed.alignSelf;
    el.style.marginTop = computed.marginTop;
    el.style.marginBottom = computed.marginBottom;
    el.style.whiteSpace = computed.whiteSpace;
  });

  test.className = "chat-right";
  const computedR = getComputedStyle(test);
  rightPreviewBoxes.forEach(el => {
    el.style.backgroundColor = computedR.backgroundColor;
    el.style.color = computedR.color;
    el.style.padding = computedR.padding;
    el.style.borderRadius = computedR.borderRadius;
    el.style.maxWidth = computedR.maxWidth;
    el.style.alignSelf = computedR.alignSelf;
    el.style.marginTop = computedR.marginTop;
    el.style.marginBottom = computedR.marginBottom;
    el.style.whiteSpace = computedR.whiteSpace;
  });

  test.remove();
  temp.remove();
}

function processText(text) {
  const lines = text.split(/\r?\n/);
  return lines.map(line => line.trim()).join("<br>");
}

function createDialogue(html, order, side) {
  const div = document.createElement("div");
  const className = side === "left" ? "dialogue chat-left left" : "dialogue chat-right right";
  div.className = className;
  div.dataset.order = order;
  div.dataset.side = side;
  div.setAttribute("draggable", true);

  const number = document.createElement("div");
  number.className = "number";

  const switchBtn = document.createElement("button");
  switchBtn.className = "switch-btn";
  switchBtn.textContent = "↔";
  switchBtn.onclick = switchSide;

  const content = document.createElement("div");
  content.className = "dialogue-content";
  content.setAttribute("contenteditable", "false");

  // 插入內容
  content.innerHTML = html.trim();

  // ✅ 支援修改模式下 Enter 可堆疊 <br>
  content.addEventListener("keydown", e => {
    if (e.key === "Enter") {
      e.preventDefault();

      const br = document.createElement("br");
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      const range = selection.getRangeAt(0);
      range.insertNode(br);

      const prevNode = br.previousSibling;
      if (prevNode && prevNode.nodeName === "BR") {
        const br2 = document.createElement("br");
        range.insertNode(br2);
        range.setStartAfter(br2);
        range.setEndAfter(br2);
      } else {
        range.setStartAfter(br);
        range.setEndAfter(br);
      }

      selection.removeAllRanges();
      selection.addRange(range);
    }
  });

  // 點擊進入編輯模式
  div.addEventListener("click", () => {
    if (mode === "edit") {
      content.setAttribute("contenteditable", "true");
      content.focus();
      saveState();
    } else {
      if (selected) selected.style.background = "";
      selected = div;
      div.style.background = "#c8e4ff";
    }
  });

  // 拖曳事件
  div.addEventListener("dragstart", () => div.classList.add("dragging"));
  div.addEventListener("dragend", () => div.classList.remove("dragging"));

  div.appendChild(number);
  div.appendChild(switchBtn);
  div.appendChild(content);

  return div;
}

function switchSide(e) {
  e.stopPropagation();
  const dlg = e.target.closest(".dialogue");
  dlg.classList.toggle("left");
  dlg.classList.toggle("right");
  dlg.classList.toggle("chat-left");
  dlg.classList.toggle("chat-right");
  dlg.dataset.side = dlg.classList.contains("left") ? "left" : "right";
  saveState();
}

function getDropTarget(e) {
  const elements = [...preview.querySelectorAll(".dialogue")];
  for (let el of elements) {
    const rect = el.getBoundingClientRect();
    if (e.clientY < rect.top + rect.height / 2) return el;
  }
  return null;
}

function refreshNumbers() {
  const dialogues = [...preview.querySelectorAll(".dialogue")];
  dialogues.forEach((el, idx) => {
    const number = el.querySelector(".number");
    if (number) number.textContent = idx + 1;
  });
}

function deleteSelected() {
  if (selected) {
    selected.remove();
    selected = null;
    refreshNumbers(); saveState();
  }
}

function mergeNextSameSide() {
  if (!selected) return alert("請先選取一個對話框");
  const all = [...preview.querySelectorAll(".dialogue")];
  const idx = all.indexOf(selected);
  if (idx < 0 || idx >= all.length - 1) return alert("沒有可合併的下一段對話");

  const next = all[idx + 1];
  if (selected.dataset.side !== next.dataset.side) return alert("下一段不是同側對話，無法合併");

  if (!confirm("⚠️ 將會合併下一段相同側對話框，是否繼續？")) return;

  const contentA = selected.querySelector(".dialogue-content");
  const contentB = next.querySelector(".dialogue-content");

  contentA.innerHTML = contentA.innerHTML.trim() + "<br><br>" + contentB.innerHTML.trim();
  next.remove();

  refreshNumbers();
  saveState();
}

function exportTxt() {
  const sharedStyle = document.getElementById("output-style").textContent;
  const leftRole = leftInput.value.trim();
  const rightRole = rightInput.value.trim();
  const dialogues = [...preview.querySelectorAll(".dialogue")];

  let result = `<style>\n${sharedStyle}\n</style>\n\n<div class="chat-container">\n`;

  dialogues.forEach(dlg => {
    const side = dlg.dataset.side;
    const align = side === "left" ? "flex-start" : "flex-end";
    const cls = side === "left" ? "chat-left" : "chat-right";
    const role = side === "left" ? leftRole : rightRole;
    const roleLine = role ? `  <div class="sender-name">${role}</div>\n` : "";
    const contentEl = dlg.querySelector(".dialogue-content");
    const contentHTML = contentEl ? contentEl.innerHTML.trim() : "";
    result += `<div class="chat-message" style="align-self: ${align};">\n${roleLine}  <div class="${cls}">${contentHTML}</div>\n</div>\n`;
  });

  result += "</div>";

  const blob = new Blob([result], { type: "text/plain;charset=utf-8" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "dialogue.txt";
  a.click();
  URL.revokeObjectURL(a.href);
}

function toggleMode() {
  mode = mode === "drag" ? "edit" : "drag";
  modeStatus.textContent = mode === "drag" ? "拖曳模式" : "修改模式";
  const contents = document.querySelectorAll(".dialogue-content");
  contents.forEach(el => {
    el.setAttribute("contenteditable", mode === "edit" ? "true" : "false");
    if (mode === "drag") el.blur();
  });
  saveState();
}

function autoConvertFromSource() {
  const rawHTML = source.innerHTML.trim();
  if (!rawHTML) return alert("請先貼上原始文本在左側區域！");

  const segments = rawHTML.split(/<br><br>/i);
  if (segments.length === 0) return;

  preview.innerHTML = ""; // 清空現有預覽
  currentOrder = 1;

  segments.forEach((seg, idx) => {
    const cleanHTML = seg.trim();
    if (!cleanHTML) return;

    // 預設奇偶決定左右
    const side = idx % 2 === 0 ? "left" : "right";
    const dlg = createDialogue(cleanHTML, currentOrder++, side);
    preview.appendChild(dlg);
  });

  refreshNumbers();
  saveState();
  alert("✅ 已轉換完成！可手動微調左右位置與角色名。");
}

function flipAllSides() {
  const dialogues = preview.querySelectorAll(".dialogue");
  dialogues.forEach(dlg => {
    if (dlg.classList.contains("chat-left")) {
      dlg.classList.remove("chat-left", "left");
      dlg.classList.add("chat-right", "right");
      dlg.dataset.side = "right";
    } else if (dlg.classList.contains("chat-right")) {
      dlg.classList.remove("chat-right", "right");
      dlg.classList.add("chat-left", "left");
      dlg.dataset.side = "left";
    }
  });
  refreshNumbers();
  saveState();
  alert("↔ 所有對話泡泡已對調左右！");
}
function saveState() {
  const data = {
    left: leftInput.value,
    right: rightInput.value,
    source: source.innerHTML,
    order: currentOrder,
    dialogues: [...preview.querySelectorAll(".dialogue")].map(dlg => {
      const contentEl = dlg.querySelector(".dialogue-content");
      const cleanedHTML = contentEl?.innerHTML
        .replace(/<div><br><\/div>/g, "<br>")
        .replace(/<div>/g, "")
        .replace(/<\/div>/g, "<br>") || "";
      return {
        side: dlg.dataset.side,
        html: cleanedHTML
      };
    })
  };

  localStorage.setItem("dialogue-style", document.getElementById("output-style").textContent);
  localStorage.setItem("dialogue-editor-save", JSON.stringify(data));
}

function loadState() {
  const savedStyle = localStorage.getItem("dialogue-style");
  if (savedStyle) {
  document.getElementById("output-style").textContent = savedStyle;
} else {
  // ✅ 如果沒有存過樣式，就使用你寫在 HTML 裡那一份
  const original = document.getElementById("output-style").textContent;
  localStorage.setItem("dialogue-style", original);
}

  const data = JSON.parse(localStorage.getItem("dialogue-editor-save") || "{}");
  if (!data.dialogues) {
    source.innerHTML = "請於此處貼上文本，選取文字後拖曳至右方工作區左側或右側生成對話框<br><br>v5.6優化：手機可以用並讓手機好用的相關功能<br><br>v5.5優化：<br>1. 工作區對話框完全地所見即所得，可修改對話框間距等，且輸出套用。<br>2. 重整後仍記憶修改後的樣式設定。<br>3. 調正樣式設定內的錯字。<br>4. 修BUG：修正原先修改模式無法任意ENTER的問題。<br><br>其他功能：<br>0. 顯示角色名可以自定義（空白則無）<br>1. 對話框右上有一個小小的雙箭頭，可以左右對調對話框的位置唷！<br>2. 同側對話框可以拖曳修改順序！<br>3. 「模式切換」按下去以後（切換成修改模式）就可以點選對話框直接進行文字修改！";
    return;
  }
  leftInput.value = data.left || "";
  rightInput.value = data.right || "";
  source.innerHTML = data.source || "";
  currentOrder = data.order || 1;
  data.dialogues.forEach(d => {
    const dlg = createDialogue(d.html, currentOrder++, d.side);
    preview.appendChild(dlg);
  });
  refreshNumbers();
  syncPreviewStyle(); // ⭐ 確保載入時立即套用樣式
}

function clearAll() {
  if (!confirm("⚠️ 本功能將完全清除所有資料，是否執行？")) return;
  leftInput.value = "";
  rightInput.value = "";
  source.innerHTML = "";
  preview.innerHTML = "";
  selected = null;
  currentOrder = 1;
  localStorage.removeItem("dialogue-editor-save");
}

window.onload = loadState;

source.addEventListener("paste", e => {
  e.preventDefault();

  const text = (e.clipboardData || window.clipboardData).getData("text/plain");

  // 將純文字的 \n 轉換為真正的 TextNode 與 <br> 結構
  const lines = text.split(/\r?\n/);
  const fragment = document.createDocumentFragment();

  lines.forEach((line, idx) => {
    fragment.appendChild(document.createTextNode(line));
    // 每行後補 <br>（即使是空行也保留）
    if (idx < lines.length - 1) fragment.appendChild(document.createElement("br"));
  });

  // 插入到當前游標位置
  const selection = window.getSelection();
  if (!selection.rangeCount) return;
  const range = selection.getRangeAt(0);
  range.deleteContents();
  range.insertNode(fragment);
});

preview.addEventListener("dragover", e => e.preventDefault());
preview.addEventListener("drop", e => {
  if (mode !== "drag") return;
  e.preventDefault();
  const dragging = document.querySelector(".dialogue.dragging");
  const dropTarget = getDropTarget(e);
  if (dragging) {
    dragging.classList.remove("dragging");
    if (dropTarget) preview.insertBefore(dragging, dropTarget);
    else preview.appendChild(dragging);
    refreshNumbers(); saveState();
  } else {
    const text = e.dataTransfer.getData("text/plain");
    if (text.trim()) {
      const html = processText(text);
      const side = e.clientX < window.innerWidth * 0.65 ? "left" : "right";
      const dlg = createDialogue(html, currentOrder++, side);
      if (dropTarget) preview.insertBefore(dlg, dropTarget);
      else preview.appendChild(dlg);
      refreshNumbers(); preview.scrollTop = preview.scrollHeight;
      saveState();
    }
  }
});
</script>
</body>
</html>
