<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>對話編輯神器：凜與GPT小天使的辛苦結晶 V5.4</title>

  <!-- 固定 UI 樣式（不讓使用者編輯） -->
  <style>
    body { margin: 0; font-family: sans-serif; height: 100vh; display: flex; flex-direction: column; }
    #header { padding: 10px; border-bottom: 1px solid #ccc; text-align: center; font-weight: bold; }
    .role-name-inputs { display: flex; justify-content: space-between; padding: 5px 10px; }
    .role-name-inputs input { width: 48%; padding: 5px; }
    #main { display: flex; flex: 1; overflow: hidden; }
    #source {
      width: 30%; padding: 10px; border-right: 1px solid #ccc;
      box-sizing: border-box; overflow-y: auto;
    }
    #preview {
      width: 70%; padding: 10px; box-sizing: border-box;
      display: flex; flex-direction: column; overflow-y: auto;
      gap: 6px;
    }
    .dialogue {
      padding: 4px 28px 6px 8px;
      margin-top: 0;
      margin-bottom: 0;
      border-radius: 5px; position: relative;
      word-break: break-word; line-height: 1.6;
      display: flex; flex-direction: column;
    }
    .dialogue-content { white-space: pre-line; }
    .number {
      position: absolute; top: 0px; left: 6px;
      font-size: 11px; color: #888; line-height: 1;
    }
.switch-btn {
  position: absolute;
  top: -5px;
  right: 6px;
  font-size: 13px;
  background: none;
  border: none;
  cursor: pointer;
  color: #666;
  line-height: 1;
}

    .dialogue.dragging { opacity: 0.5; }
    #controls {
      padding: 10px; text-align: center; border-top: 1px solid #ccc;
      display: flex; justify-content: center; align-items: center;
      flex-wrap: wrap; gap: 10px;
    }
    .dialogue.chat-left, 
    .dialogue.chat-right {
      margin-top: 0;
      margin-bottom: 0;
    }
    .dialogue-content:first-child,
    .dialogue-content br:first-child {
      margin-top: 0;
      padding-top: 0;
      line-height: 0;
      height: 0;
      display: none;
    }
    button { padding: 8px 15px; }
    #clearAllBtn { background: #f44336; color: white; }
    #styleEditorModal {
      position: fixed; top: 10%; left: 50%; transform: translateX(-50%);
      background: white; border: 1px solid #ccc; padding: 10px;
      z-index: 9999; width: 80%; height: 70%; display: none; flex-direction: column;
    }
    #styleEditorModal textarea {
      flex: 1; width: 100%; font-family: monospace;
      font-size: 14px; margin-bottom: 10px;
    }
  </style>

  <!-- 使用者可編輯的輸出樣式 -->
  <style id="output-style">
.chat-container {
  display: flex; /* 這邊都不要動，往下拉 */
  flex-direction: column;
  gap: 20px;
  width: 100%;
  font-family: Arial, sans-serif;
  font-weight: 400;
  max-width: 100%;
}
.chat-message {
  display: flex;
  flex-direction: column;
  width: 100%;
  max-width: 100%;
  margin-top: 0;
  margin-bottom: 0;
}
.sender-name {
  font-size: 12px; /* 理論上是改人名的相關設定，但未經測試 */
  font-weight: bold;
  margin-bottom: 3px;
  color: #666;
}
.chat-left, .chat-right {
  display: inline-block;
  padding: 10px;
  border-radius: 10px;
  word-wrap: break-word;
  white-space: pre-wrap;
  min-width: 40px;
  width: auto;
  margin-top: 0;
  margin-bottom: 0;
}
.chat-left {
  background-color: #f1f1f1; /* 右邊對話框背景色 */
  color: #3C3C3C; /* 右邊對話框字體色 */
  align-self: flex-start;
  max-width: 70%; /* 對話框寬度佔畫面百分比 */
}
.chat-right {
  background-color: #FFC1E0; /* 右邊對話框背景色 */
  color: #3C3C3C; /* 右邊對話框字體色 */
  align-self: flex-end;
  max-width: 70%;
}
  </style>
</head>
<body>
    <div style="text-align: right; padding: 5px;">
    <a href="https://github.com/LuciferseyeBL/dialogue-editor" target="_blank">
      📘 查看 GitHub 說明文件（README）
    </a>
  </div>
  <div id="header">📚 對話編輯神器：凜與GPT小天使的辛苦結晶 V5.4</div>
  <div class="role-name-inputs">
    <input id="leftRole" placeholder="左側角色名 (可留空)" />
    <input id="rightRole" placeholder="右側角色名 (可留空)" />
  </div>
  <div id="main">
    <div id="source" contenteditable="true"></div>
    <div id="preview"></div>
  </div>
  <div id="controls">
    <button onclick="openStyleEditor()">樣式設定</button>
    <button onclick="deleteSelected()">刪除</button>
    <button onclick="mergeNextSameSide()">合併下方同側</button>
    <button onclick="exportTxt()">匯出 TXT</button>
    <button onclick="toggleMode()">模式切換</button>
    <span id="mode-status">拖曳模式</span>
    <button id="clearAllBtn" onclick="clearAll()">全部清除</button>
  </div>
  <div id="styleEditorModal">
    <textarea id="styleEditorArea"></textarea>
    <button onclick="applyStyle()">套用樣式</button>
    <button onclick="closeStyleEditor()">關閉</button>
  </div>
<script>
let selected = null;
let currentOrder = 1;
let mode = "drag";

const preview = document.getElementById("preview");
const modeStatus = document.getElementById("mode-status");
const leftInput = document.getElementById("leftRole");
const rightInput = document.getElementById("rightRole");
const source = document.getElementById("source");

function openStyleEditor() {
  const styleText = document.getElementById("output-style").textContent;
  document.getElementById("styleEditorArea").value = styleText;
  document.getElementById("styleEditorModal").style.display = "flex";
}

function closeStyleEditor() {
  document.getElementById("styleEditorModal").style.display = "none";
}

function applyStyle() {
  const updated = document.getElementById("styleEditorArea").value;
  document.getElementById("output-style").textContent = updated;
  closeStyleEditor();
}

function processText(text) {
  const lines = text
    .split(/\r?\n/)
    .map(line => line.trim())
    .filter(line => line.length > 0);

  // 如果完全沒有內容，就回傳空字串
  if (lines.length === 0) return "";

  return lines.join("<br>");
}

function createDialogue(html, order, side) {
  const div = document.createElement("div");
  const className = side === "left" ? "dialogue chat-left left" : "dialogue chat-right right";
  div.className = className;
  div.dataset.order = order;
  div.dataset.side = side;
  div.setAttribute("draggable", true);

  const number = document.createElement("div");
  number.className = "number";

  const switchBtn = document.createElement("button");
  switchBtn.className = "switch-btn";
  switchBtn.textContent = "↔";
  switchBtn.onclick = switchSide;

  const content = document.createElement("div");
  content.className = "dialogue-content";
  content.setAttribute("contenteditable", "false");

  // 真正乾淨插入內容，不讓 HTML 包任何奇怪段落
  content.innerHTML = html.trim();

  div.appendChild(number);
  div.appendChild(switchBtn);
  div.appendChild(content);

  div.addEventListener("dragstart", () => div.classList.add("dragging"));
  div.addEventListener("dragend", () => div.classList.remove("dragging"));
  div.addEventListener("click", () => {
    if (mode === "edit") {
      content.setAttribute("contenteditable", "true");
      content.focus();
      saveState();
    } else {
      if (selected) selected.style.background = "";
      selected = div;
      div.style.background = "#c8e4ff";
    }
  });

  return div;
}

function switchSide(e) {
  e.stopPropagation();
  const dlg = e.target.closest(".dialogue");
  dlg.classList.toggle("left");
  dlg.classList.toggle("right");
  dlg.classList.toggle("chat-left");
  dlg.classList.toggle("chat-right");
  dlg.dataset.side = dlg.classList.contains("left") ? "left" : "right";
  saveState();
}

function getDropTarget(e) {
  const elements = [...preview.querySelectorAll(".dialogue")];
  for (let el of elements) {
    const rect = el.getBoundingClientRect();
    if (e.clientY < rect.top + rect.height / 2) return el;
  }
  return null;
}

function refreshNumbers() {
  const dialogues = [...preview.querySelectorAll(".dialogue")];
  dialogues.forEach((el, idx) => {
    const number = el.querySelector(".number");
    if (number) number.textContent = idx + 1;
  });
}

function deleteSelected() {
  if (selected) {
    selected.remove();
    selected = null;
    refreshNumbers(); saveState();
  }
}

function mergeNextSameSide() {
  if (!selected) return alert("請先選取一個對話框");
  const all = [...preview.querySelectorAll(".dialogue")];
  const idx = all.indexOf(selected);
  if (idx < 0 || idx >= all.length - 1) return alert("沒有可合併的下一段對話");

  const next = all[idx + 1];
  if (selected.dataset.side !== next.dataset.side) return alert("下一段不是同側對話，無法合併");

  if (!confirm("⚠️ 將會合併下一段相同側對話框，是否繼續？")) return;

  const contentA = selected.querySelector(".dialogue-content");
  const contentB = next.querySelector(".dialogue-content");

  contentA.innerHTML = contentA.innerHTML.trim() + "<br><br>" + contentB.innerHTML.trim();
  next.remove();

  refreshNumbers();
  saveState();
}

function exportTxt() {
  const sharedStyle = document.getElementById("output-style").textContent;
  const leftRole = leftInput.value.trim();
  const rightRole = rightInput.value.trim();
  const dialogues = [...preview.querySelectorAll(".dialogue")];

  let result = `<style>\n${sharedStyle}\n</style>\n\n<div class="chat-container">\n`;

  dialogues.forEach(dlg => {
    const side = dlg.dataset.side;
    const align = side === "left" ? "flex-start" : "flex-end";
    const cls = side === "left" ? "chat-left" : "chat-right";
    const role = side === "left" ? leftRole : rightRole;
    const roleLine = role ? `  <div class="sender-name">${role}</div>\n` : "";
    const contentEl = dlg.querySelector(".dialogue-content");
    const contentHTML = contentEl ? contentEl.innerHTML.trim() : "";
    result += `<div class="chat-message" style="align-self: ${align};">\n${roleLine}  <div class="${cls}">${contentHTML}</div>\n</div>\n`;
  });

  result += "</div>";

  const blob = new Blob([result], { type: "text/plain;charset=utf-8" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "dialogue.txt";
  a.click();
  URL.revokeObjectURL(a.href);
}

function toggleMode() {
  mode = mode === "drag" ? "edit" : "drag";
  modeStatus.textContent = mode === "drag" ? "拖曳模式" : "修改模式";
  const contents = document.querySelectorAll(".dialogue-content");
  contents.forEach(el => {
    el.setAttribute("contenteditable", mode === "edit" ? "true" : "false");
    if (mode === "drag") el.blur();
  });
  saveState();
}

function saveState() {
  const data = {
    left: leftInput.value,
    right: rightInput.value,
    source: source.innerHTML,
    order: currentOrder,
    dialogues: [...preview.querySelectorAll(".dialogue")].map(dlg => ({
      side: dlg.dataset.side,
      html: dlg.querySelector(".dialogue-content")?.innerHTML || ""
    }))
  };
  localStorage.setItem("dialogue-editor-save", JSON.stringify(data));
}

function loadState() {
  const data = JSON.parse(localStorage.getItem("dialogue-editor-save") || "{}");
  if (!data.dialogues) {
    source.innerHTML = "請於此處貼上文本，選取文字後拖曳至右方工作區左側或右側生成對話框<br><br>其他功能：<br>0. 顯示角色名可以自定義（空白則無）<br>1. 對話框右上有一個小小的雙箭頭，可以左右對調對話框的位置唷！<br>2. 同側的對話框可以拖曳修改順序！<br>3. 「合併下方同側」可以把兩個對話框合併成一個，點選想要操作的對話框就可以了～<br>4. 「模式切換」按下去以後（切換成修改模式）就可以點選對話框直接進行文字修改！";
    return;
  }
  leftInput.value = data.left || "";
  rightInput.value = data.right || "";
  source.innerHTML = data.source || "";
  currentOrder = data.order || 1;
  data.dialogues.forEach(d => {
    const dlg = createDialogue(d.html, currentOrder++, d.side);
    preview.appendChild(dlg);
  });
  refreshNumbers();
}

function clearAll() {
  if (!confirm("⚠️ 本功能將完全清除所有資料，是否執行？")) return;
  leftInput.value = "";
  rightInput.value = "";
  source.innerHTML = "";
  preview.innerHTML = "";
  selected = null;
  currentOrder = 1;
  localStorage.removeItem("dialogue-editor-save");
}

window.onload = loadState;

preview.addEventListener("dragover", e => e.preventDefault());
preview.addEventListener("drop", e => {
  if (mode !== "drag") return;
  e.preventDefault();
  const dragging = document.querySelector(".dialogue.dragging");
  const dropTarget = getDropTarget(e);
  if (dragging) {
    dragging.classList.remove("dragging");
    if (dropTarget) preview.insertBefore(dragging, dropTarget);
    else preview.appendChild(dragging);
    refreshNumbers(); saveState();
  } else {
    const text = e.dataTransfer.getData("text/plain");
    if (text.trim()) {
      const html = processText(text);
      const side = e.clientX < window.innerWidth * 0.65 ? "left" : "right";
      const dlg = createDialogue(html, currentOrder++, side);
      if (dropTarget) preview.insertBefore(dlg, dropTarget);
      else preview.appendChild(dlg);
      refreshNumbers(); preview.scrollTop = preview.scrollHeight;
      saveState();
    }
  }
});
</script>
</body>
</html>
